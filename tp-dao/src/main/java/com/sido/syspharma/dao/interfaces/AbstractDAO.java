package com.sido.syspharma.dao.interfaces; // Ou le package où vous voulez le placer

import com.sido.syspharma.dao.database.ConnexionDB; // Import de ConnexionDB
import com.sido.syspharma.dao.exceptions.DatabaseException;
import org.apache.log4j.Logger;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

/**
 * Classe de base abstraite pour les Data Access Objects (DAO).
 * Fournit des méthodes utilitaires pour exécuter des opérations JDBC
 * en gérant l'ouverture et la fermeture de la connexion.
 */
public abstract class AbstractDAO {

    private static final Logger logger = Logger.getLogger(AbstractDAO.class);

    // Interface fonctionnelle pour les opérations qui ne retournent pas de ResultSet (ex: INSERT, UPDATE, DELETE)
    @FunctionalInterface
    protected interface StatementOperation {
        void apply(PreparedStatement stmt) throws SQLException;
    }

    // Interface fonctionnelle pour les opérations qui retournent un ResultSet et un résultat mappé
    @FunctionalInterface
    protected interface QueryOperation<T> {
        T apply(PreparedStatement stmt, ResultSet rs) throws SQLException;
    }

    // Interface fonctionnelle pour les opérations qui utilisent un PreparedStatement et retournent un résultat
    @FunctionalInterface
    protected interface PreparedStatementCallback<T> {
        T doInPreparedStatement(PreparedStatement stmt) throws SQLException;
    }


    /**
     * Exécute une opération de mise à jour (INSERT, UPDATE, DELETE).
     * Gère l'ouverture/fermeture de la connexion et la préparation du statement.
     *
     * @param sql La requête SQL à exécuter.
     * @param operation L'opération à effectuer avec le PreparedStatement (ex: définir les paramètres).
     * @param autoGeneratedKeys Indique si les clés auto-générées doivent être récupérables.
     * @return Le nombre de lignes affectées, ou l'ID généré si autoGeneratedKeys est utilisé et qu'une clé est retournée.
     * @throws DatabaseException Si une erreur survient.
     */
    protected long executeUpdate(String sql, StatementOperation operation, boolean retrieveGeneratedKeys) throws DatabaseException {
        try (Connection connection = ConnexionDB.getConnection();
             PreparedStatement stmt = retrieveGeneratedKeys ?
                     connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS) :
                     connection.prepareStatement(sql)) {
            operation.apply(stmt); // Appliquer les paramètres
            int affectedRows = stmt.executeUpdate();

            if (retrieveGeneratedKeys && affectedRows > 0) {
                try (ResultSet generatedKeys = stmt.getGeneratedKeys()) {
                    if (generatedKeys.next()) {
                        return generatedKeys.getLong(1); // Retourne l'ID généré
                    } else {
                        logger.warn("executeUpdate avec retrieveGeneratedKeys n'a pas retourné d'ID, mais " + affectedRows + " lignes affectées.");
                        return affectedRows; // Ou lever une exception si un ID était attendu
                    }
                }
            }
            return affectedRows; // Retourne le nombre de lignes affectées
        } catch (SQLException e) {
            logger.error("Erreur SQL lors de l'exécution de la mise à jour: " + sql, e);
            throw new DatabaseException("Erreur lors de l'exécution de la mise à jour: " + e.getMessage(), e);
        }
    }

    /**
     * Exécute une requête SELECT et mappe le premier résultat.
     * Gère l'ouverture/fermeture de la connexion, la préparation du statement et le ResultSet.
     *
     * @param sql La requête SQL à exécuter.
     * @param paramsSetter Opération pour définir les paramètres du PreparedStatement.
     * @param rowMapper Opération pour mapper une ligne du ResultSet vers un objet de type R.
     * @param <R> Le type de l'objet retourné.
     * @return Un Optional contenant l'objet mappé s'il est trouvé, sinon Optional.empty().
     * @throws DatabaseException Si une erreur survient.
     */
    protected <R> Optional<R> executeQueryForSingleResult(String sql, StatementOperation paramsSetter, RowMapper<R> rowMapper) throws DatabaseException {
        try (Connection connection = ConnexionDB.getConnection();
             PreparedStatement stmt = connection.prepareStatement(sql)) {
            paramsSetter.apply(stmt); // Définir les paramètres
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    return Optional.of(rowMapper.mapRow(rs));
                } else {
                    return Optional.empty();
                }
            }
        } catch (SQLException e) {
            logger.error("Erreur SQL lors de l'exécution de la requête (single result): " + sql, e);
            throw new DatabaseException("Erreur lors de l'exécution de la requête: " + e.getMessage(), e);
        }
    }

    /**
     * Exécute une requête SELECT et mappe tous les résultats dans une liste.
     * Gère l'ouverture/fermeture de la connexion, la préparation du statement et le ResultSet.
     *
     * @param sql La requête SQL à exécuter.
     * @param paramsSetter Opération pour définir les paramètres du PreparedStatement (peut être null ou une op vide si pas de params).
     * @param rowMapper Opération pour mapper une ligne du ResultSet vers un objet de type R.
     * @param <R> Le type des objets dans la liste retournée.
     * @return Une liste d'objets mappés.
     * @throws DatabaseException Si une erreur survient.
     */
    protected <R> List<R> executeQueryForList(String sql, StatementOperation paramsSetter, RowMapper<R> rowMapper) throws DatabaseException {
        List<R> results = new ArrayList<>();
        try (Connection connection = ConnexionDB.getConnection();
             PreparedStatement stmt = connection.prepareStatement(sql)) {
            if (paramsSetter != null) {
                paramsSetter.apply(stmt); // Définir les paramètres si nécessaire
            }
            try (ResultSet rs = stmt.executeQuery()) {
                while (rs.next()) {
                    results.add(rowMapper.mapRow(rs));
                }
            }
        } catch (SQLException e) {
            logger.error("Erreur SQL lors de l'exécution de la requête (list result): " + sql, e);
            throw new DatabaseException("Erreur lors de l'exécution de la requête: " + e.getMessage(), e);
        }
        return results;
    }

    /**
     * Interface fonctionnelle pour mapper une ligne d'un ResultSet à un objet.
     * @param <T> Le type de l'objet à mapper.
     */
    @FunctionalInterface
    protected interface RowMapper<T> {
        T mapRow(ResultSet rs) throws SQLException;
    }

    // Pour la testabilité, si vous voulez injecter une source de connexion mockée :
    // Vous pourriez ajouter un constructeur à AbstractDAO qui prend un ConnectionProvider
    // et l'utiliser au lieu de ConnexionDB.getConnection() directement.
    // C'est une amélioration supplémentaire pour une testabilité encore plus poussée.
    // Exemple:
    // protected ConnectionProvider connectionProvider;
    // public AbstractDAO(ConnectionProvider provider) { this.connectionProvider = provider; }
    // protected AbstractDAO() { this.connectionProvider = () -> ConnexionDB.getConnection(); } // Constructeur par défaut
    // Et ensuite utiliser this.connectionProvider.getConnection() dans les méthodes execute.
}